package mylog

import (
	"context"
	"io"
	"os"
	"strings"

	log "github.com/sirupsen/logrus"
)

// MyLogger interface
type MyLogger interface {
	Debugf(format string, v ...interface{})
	Infof(format string, v ...interface{})
	Warnf(format string, v ...interface{})
	Errorf(format string, v ...interface{})
	Fatalf(format string, v ...interface{})
	GetEntryWithFields(m map[string]interface{}) *Logger
	GetField(key string) interface{}
}

const (
	// Lfile log with fileline
	Lfile = 1 << iota
	// Ljson json format
	Ljson
	// Lrelative use relative path
	Lrelative
	// Lwelog copy warning and error log to another output
	Lwelog
)

// LogLevel map level string to log.Level
var LogLevel = map[string]log.Level{
	"DEBUG": log.DebugLevel,
	"INFO":  log.InfoLevel,
	"WARN":  log.WarnLevel,
	"ERROR": log.ErrorLevel,
	"FATAL": log.FatalLevel,
}

// EntryKey type of entryKey
type EntryKey string

var entryKey EntryKey = "logEntry"
var stdLog = New("DEBUG", os.Stderr, Lfile)

func getLogLevel(level string) log.Level {
	l, ok := LogLevel[strings.ToUpper(level)]
	if !ok {
		return log.DebugLevel
	}

	return l
}

// New return a new Logger, Lrelative, Lwelog is invalid in this function
func New(level string, out io.Writer, flag int) *Logger {
	return NewWithRelativePath(level, out, flag, "", nil)
}

// NewWithRelativePath return a new Logger, relativePath: ignore prefix from path
func NewWithRelativePath(level string, out io.Writer, flag int, relativePath string, errout io.Writer) *Logger {
	myLogger := &Logger{Logger: newLogger(level, out, flag, relativePath)}
	if flag&Lwelog != 0 && errout != nil {
		myLogger.welog = newLogger(level, errout, flag, relativePath)
	}

	return myLogger
}

func newLogger(level string, out io.Writer, flag int, relativePath string) *log.Logger {
	Log := log.New()
	Log.Level = getLogLevel(level)
	Log.Out = out
	if flag&Ljson != 0 {
		Log.Formatter = &log.JSONFormatter{}
	}

	if flag&Lfile != 0 {
		flHook := FileLineHook{}
		if flag&Lrelative != 0 {
			flHook.IsRelative = true
			flHook.IgnorePrefix = relativePath
		}

		Log.Hooks.Add(flHook)
	}

	return Log
}

// Init initilize stdLog
func Init(level string, out io.Writer, flag int, relativePath string, errout io.Writer) {
	stdLog = NewWithRelativePath(level, out, flag, relativePath, errout)
}

// GetStdLog export stdLog
func GetStdLog() *Logger {
	return stdLog
}

// Predefine stdLog with fixed extra record
func Predefine(m map[string]interface{}) {
	stdLog.Predefine(m)
}

// Debugf stdLog with debug level
func Debugf(format string, v ...interface{}) {
	stdLog.Debugf(format, v...)
}

// Infof stdLog with info level
func Infof(format string, v ...interface{}) {
	stdLog.Infof(format, v...)
}

// Warnf stdLog with warn level
func Warnf(format string, v ...interface{}) {
	stdLog.Warnf(format, v...)
}

// Errorf stdLog with error level
func Errorf(format string, v ...interface{}) {
	stdLog.Errorf(format, v...)
}

// Fatalf stdLog with fatal level
func Fatalf(format string, v ...interface{}) {
	stdLog.Fatalf(format, v...)
}

// GetEntryWithFields return an entry(*Logger) with fileds, inherit origin fields from stdLog
func GetEntryWithFields(m map[string]interface{}) *Logger {
	return stdLog.GetEntryWithFields(m)
}

// GetField return field of key from stdLog
func GetField(key string) interface{} {
	return stdLog.GetField(key)
}

// GetCtxEntry get entry(*Logger) from context; if no entry in context, return a new entry generated by log
func GetCtxEntry(ctx context.Context, log MyLogger) *Logger {
	entry, ok := ctx.Value(entryKey).(*Logger)
	if !ok {
		return log.GetEntryWithFields(nil)
	}

	return entry
}

// SetCtxEntry set entry(*Logger) into context
func SetCtxEntry(ctx context.Context, e *Logger) context.Context {
	return context.WithValue(ctx, entryKey, e)
}
